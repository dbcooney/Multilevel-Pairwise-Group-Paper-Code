"""
This script is used to generate Figures 6.3 and 6.4, providing illustrations
of the average fraction of cooperation and average collective success of the long-time
population for various strengths of group-level selection in the case of a multilevel
PD scenario and the Fermi update rule. This figure uses data included 
in the Simulation_Outputs folder, which is generated by running the script 
"loopfvpairwise.py" in the Scripts folder.
"""


import numpy as np
import matplotlib.pyplot as plt
import matplotlib
matplotlib.use('TkAgg')
import os


from matplotlib import rc
rc('font',**{'family':'sans-serif','sans-serif':['Helvetica']})
## for Palatino and other serif fonts use:
#rc('font',**{'family':'serif','serif':['Palatino']})
rc('text', usetex=True)

eta = 1.0

plt.figure(1)

"""
Defining files of simulation outputs that will be used to generate figures for pairwise
local group-level victory probability.
"""




script_folder = os.getcwd()
pairwise_folder = os.path.dirname(script_folder)

file1 = pairwise_folder + "/Simulation_Outputs/Rho1xPDgamma1p5P1.txt"
file2 = pairwise_folder + "/Simulation_Outputs/AvgGPDgamma1p5P1.txt"
file3 = pairwise_folder + "/Simulation_Outputs/PeakPDgamma1p5P1.txt"
file4 = pairwise_folder + "/Simulation_Outputs/MeanCoopPDEgamma1p5P1.txt"




def process(list):
	list = list.split(',')
	list = [float(a) for a in list]
	return list

def find_lamb_list(f):
	f.readline()
	lamb_list = f.readline()
	lamb_list = process(lamb_list)
	return lamb_list
	


def data_list(f):
	f.readline()
		
	quantity_list = f.readline()
	quantity_list = process(quantity_list)
	return quantity_list	
	
def G(alpha,gamma,x):
	return gamma * x + alpha * (x ** 2.)
	
def rho(x,y,alpha,gamma,s):
	Gx = G(alpha,gamma,x)
	Gy = G(alpha,gamma,y)
	return 0.5 + 0.5 * np.tanh(s * (Gx - Gy))
	
def pi_diff(alpha,beta):
	return -(beta + alpha)
		
def lambda_star_PD(alpha,beta,gamma,s, theta):
	num = pi_diff(alpha,beta) * theta
	denom = rho(1,0,alpha,gamma,s) - rho(0,1,alpha,gamma,s)
	return num / denom
	
P = 1.
alpha = -1.
beta = -1.
gamma = 1.5
s = 1.
theta = 1.
	
	
"""
Reading in data from simulation outputs for the case of a multilevel PD scenario with the
Fermi group-level victory probability and game-theoretic parameters given by
\gamma = 1.5, \alpha = -1, and \beta = -1.
"""

	
f1 = open(file1, 'r+')

lamb_list = find_lamb_list(f1)
print(lamb_list)
print(len(lamb_list))


numerical_rho1x_list = data_list(f1)
numerical_rhox1_list = [1.0 - a for a in numerical_rho1x_list]

print(numerical_rho1x_list)

analytical_rho1x_list = data_list(f1)
analytical_rhox1_list = [1.0 - a for a in analytical_rho1x_list]
print(analytical_rho1x_list)

f1.close()


f2 = open(file2,'r+')

lamb_list = find_lamb_list(f2)
avg_G_list = data_list(f2)

print(avg_G_list)

f2.close()


f4 = open(file4,'r+')

lamb_list = find_lamb_list(f4)
avg_coop_list = data_list(f4)

print(avg_coop_list)

f4.close()


"""
Figure comparing average group-level victory probability of the long-time population when
engaged in pairwise competition with the all-cooperator group.
"""

plt.figure(1)

plt.plot(lamb_list,numerical_rhox1_list, lw = 7., label =r"Numerically Computed $\langle \rho(\cdot,1) \rangle_f$")
plt.plot(lamb_list,analytical_rhox1_list, lw = 5., ls = '--', label = r"Analytical Prediction for $\langle \rho(\cdot,1) \rangle_f$")

plt.axhline(y = 0.5, lw = 5., ls = '-.', alpha = 0.8, color = 'k')
plt.axvline(x = lambda_star_PD(alpha,beta,gamma,s,theta), lw = 5., ls = '-.', alpha = 0.8, color = 'k')

plt.axis([0.,40.,0.,1.])

plt.title(r"Steady State Victory Probability $\langle \rho(\cdot,1)\rangle_f$", fontsize = 18.)
plt.xlabel(r"Strength of Between-Group Competition $\lambda$", fontsize = 20., labelpad = 10.)
plt.ylabel(r"Success of All-Cooperator Group", fontsize =18.)

plt.legend(loc = "upper right", fontsize = 16.)

plt.annotate(r"$\lambda^*_{PD}$", xy = (5.5,0.8), fontsize = 20.)
plt.annotate(r"$\rho(1,1) = 0.5$", xy = (24,0.55), fontsize = 20.)


plt.tight_layout()

plt.savefig(pairwise_folder + "/Figures/PD_rhox1_plot.png")


"""
Figure providing the average fraction of cooperation achieved under the numerical simulations
after 9,600 timesteps, plotted as a function of the relative strength \lambda of
group-level competition. 
"""


plt.figure(2)

plt.plot(lamb_list,avg_coop_list, lw = 7., label =r"$\langle x \rangle_{f(x)}$")

plt.xlabel(r"Strength of Between-Group Competition $\lambda$", fontsize = 20., labelpad = 10.)
plt.ylabel(r"Fraction of Cooperators $x$", fontsize = 20.)
plt.title(r"Average Cooperation at Steady State $\langle x \rangle_{f(x)}$", fontsize = 18.)

plt.axis([0.,75.,0.,1.])

plt.axhline(y = 0.75, lw = 5., ls = '-.', color = 'k', alpha = 0.8)
plt.axhline(y = 0.5, lw = 5., ls = '-.', color = 'k', alpha = 0.8)

plt.axvline(x = lambda_star_PD(alpha,beta,gamma,s,theta), lw = 5., ls = '-.', alpha = 0.8, color = 'k')

plt.annotate(r"$x^* = 0.75$", xy = (60.,.775), fontsize =18.)
plt.annotate(r"$\overline{x} = 0.5$", xy = (60.,.525), fontsize =18.)

plt.annotate(r"$\lambda^*_{PD}$", xy = (6.,0.9), fontsize = 18.)

plt.legend(loc = "lower right", fontsize = 20.)

plt.tight_layout()

plt.savefig(pairwise_folder + "/Figures/avgx_plot.png")



"""
Figure providing the average payoff achieved under the numerical simulations
after 9,600 timesteps, plotted as a function of the relative strength \lambda of
group-level competition. 
"""


plt.figure(3)

plt.plot(lamb_list,avg_G_list, lw = 7., label =r"$\langle G(x)\rangle_{f(x)}$")


plt.xlabel(r"Strength of Between-Group Competition $\lambda$", fontsize = 20., labelpad = 10.)
plt.ylabel(r"Average Payoff $G(x)$", fontsize = 20.)

plt.legend(loc = "lower right", fontsize = 16.)

plt.axvline(x = lambda_star_PD(alpha,beta,gamma,s,theta), lw = 5., ls = '-.', alpha = 0.8, color = 'k')
plt.annotate(r"$\lambda^*_{PD}$", xy = (1.6,0.2), fontsize = 20.)


plt.axhline(y = P, lw = 5., ls = '-.', color = 'k', alpha = 0.8)
plt.axhline(y = gamma + alpha + P, lw = 5., ls = '-.', color = 'k', alpha = 0.8)
plt.axhline(y = P + ((gamma**2.) / (-4. * alpha)), lw = 5., ls = '-.', color = 'k', alpha = 0.8)
plt.axis([0.,70.,0.,2.])

plt.tight_layout()

plt.show()
